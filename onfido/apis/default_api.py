# coding: utf-8

"""
    Onfido API

    The Onfido API is used to submit check requests.

    OpenAPI spec version: 2.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class DefaultApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def cancel_report(self, check_id, report_id, **kwargs):
        """
        This endpoint is for cancelling individual paused reports.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_report(check_id, report_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :param str report_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_report_with_http_info(check_id, report_id, **kwargs)
        else:
            (data) = self.cancel_report_with_http_info(check_id, report_id, **kwargs)
            return data

    def cancel_report_with_http_info(self, check_id, report_id, **kwargs):
        """
        This endpoint is for cancelling individual paused reports.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_report_with_http_info(check_id, report_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :param str report_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['check_id', 'report_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params) or (params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `cancel_report`")
        # verify the required parameter 'report_id' is set
        if ('report_id' not in params) or (params['report_id'] is None):
            raise ValueError("Missing the required parameter `report_id` when calling `cancel_report`")


        collection_formats = {}

        resource_path = '/checks/{check_id}/reports/{report_id}/cancel'.replace('{format}', 'json')
        path_params = {}
        if 'check_id' in params:
            path_params['check_id'] = params['check_id']
        if 'report_id' in params:
            path_params['report_id'] = params['report_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def create_applicant(self, **kwargs):
        """
        Create Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_applicant(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Applicant data: 
        :return: Applicant
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_applicant_with_http_info(**kwargs)
        else:
            (data) = self.create_applicant_with_http_info(**kwargs)
            return data

    def create_applicant_with_http_info(self, **kwargs):
        """
        Create Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_applicant_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Applicant data: 
        :return: Applicant
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_applicant" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/applicants'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Applicant',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def create_check(self, applicant_id, **kwargs):
        """
        Create a check
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_check(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param CheckCreationRequest data: 
        :return: Check
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_check_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.create_check_with_http_info(applicant_id, **kwargs)
            return data

    def create_check_with_http_info(self, applicant_id, **kwargs):
        """
        Create a check
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_check_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param CheckCreationRequest data: 
        :return: Check
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_check" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `create_check`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/checks'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Check',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def create_webhook(self, **kwargs):
        """
        Create a webhook
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_webhook(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Webhook data: 
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_webhook_with_http_info(**kwargs)
        else:
            (data) = self.create_webhook_with_http_info(**kwargs)
            return data

    def create_webhook_with_http_info(self, **kwargs):
        """
        Create a webhook
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_webhook_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Webhook data: 
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_webhook" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/webhooks'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Webhook',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def destroy_applicant(self, applicant_id, **kwargs):
        """
        Delete Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.destroy_applicant(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.destroy_applicant_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.destroy_applicant_with_http_info(applicant_id, **kwargs)
            return data

    def destroy_applicant_with_http_info(self, applicant_id, **kwargs):
        """
        Delete Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.destroy_applicant_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method destroy_applicant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `destroy_applicant`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def download_document(self, applicant_id, document_id, **kwargs):
        """
        Download a documents raw data
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_document(applicant_id, document_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str document_id:  (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.download_document_with_http_info(applicant_id, document_id, **kwargs)
        else:
            (data) = self.download_document_with_http_info(applicant_id, document_id, **kwargs)
            return data

    def download_document_with_http_info(self, applicant_id, document_id, **kwargs):
        """
        Download a documents raw data
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_document_with_http_info(applicant_id, document_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str document_id:  (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'document_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `download_document`")
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params) or (params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `download_document`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/documents/{document_id}/download'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['image/png', 'image/jpeg', 'applicant/pdf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='file',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def download_live_photo(self, live_photo_id, **kwargs):
        """
        Download live photo
        Live photos are downloaded using this endpoint.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_live_photo(live_photo_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str live_photo_id: The live photo’s unique identifier. (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.download_live_photo_with_http_info(live_photo_id, **kwargs)
        else:
            (data) = self.download_live_photo_with_http_info(live_photo_id, **kwargs)
            return data

    def download_live_photo_with_http_info(self, live_photo_id, **kwargs):
        """
        Download live photo
        Live photos are downloaded using this endpoint.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_live_photo_with_http_info(live_photo_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str live_photo_id: The live photo’s unique identifier. (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['live_photo_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_live_photo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'live_photo_id' is set
        if ('live_photo_id' not in params) or (params['live_photo_id'] is None):
            raise ValueError("Missing the required parameter `live_photo_id` when calling `download_live_photo`")


        collection_formats = {}

        resource_path = '/live_photos/{live_photo_id}/download'.replace('{format}', 'json')
        path_params = {}
        if 'live_photo_id' in params:
            path_params['live_photo_id'] = params['live_photo_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='file',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_addresses(self, postcode, **kwargs):
        """
        Search for addresses by postcode
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_addresses(postcode, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str postcode:  (required)
        :return: GenericAddressesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_addresses_with_http_info(postcode, **kwargs)
        else:
            (data) = self.find_addresses_with_http_info(postcode, **kwargs)
            return data

    def find_addresses_with_http_info(self, postcode, **kwargs):
        """
        Search for addresses by postcode
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_addresses_with_http_info(postcode, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str postcode:  (required)
        :return: GenericAddressesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['postcode']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_addresses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'postcode' is set
        if ('postcode' not in params) or (params['postcode'] is None):
            raise ValueError("Missing the required parameter `postcode` when calling `find_addresses`")


        collection_formats = {}

        resource_path = '/addresses/pick'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'postcode' in params:
            query_params['postcode'] = params['postcode']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='GenericAddressesList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_applicant(self, applicant_id, **kwargs):
        """
        Retrieve Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_applicant(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: Applicant
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_applicant_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.find_applicant_with_http_info(applicant_id, **kwargs)
            return data

    def find_applicant_with_http_info(self, applicant_id, **kwargs):
        """
        Retrieve Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_applicant_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: Applicant
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_applicant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `find_applicant`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Applicant',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_check(self, applicant_id, check_id, **kwargs):
        """
        Retrieve a Check
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_check(applicant_id, check_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str check_id:  (required)
        :return: Check
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_check_with_http_info(applicant_id, check_id, **kwargs)
        else:
            (data) = self.find_check_with_http_info(applicant_id, check_id, **kwargs)
            return data

    def find_check_with_http_info(self, applicant_id, check_id, **kwargs):
        """
        Retrieve a Check
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_check_with_http_info(applicant_id, check_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str check_id:  (required)
        :return: Check
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'check_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_check" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `find_check`")
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params) or (params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `find_check`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/checks/{check_id}'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']
        if 'check_id' in params:
            path_params['check_id'] = params['check_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Check',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_document(self, applicant_id, document_id, **kwargs):
        """
        A single document can be retrieved by calling this endpoint with the document’s unique identifier.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_document(applicant_id, document_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str document_id:  (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_document_with_http_info(applicant_id, document_id, **kwargs)
        else:
            (data) = self.find_document_with_http_info(applicant_id, document_id, **kwargs)
            return data

    def find_document_with_http_info(self, applicant_id, document_id, **kwargs):
        """
        A single document can be retrieved by calling this endpoint with the document’s unique identifier.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_document_with_http_info(applicant_id, document_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str document_id:  (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'document_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `find_document`")
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params) or (params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `find_document`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/documents/{document_id}'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Document',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_live_photo(self, live_photo_id, **kwargs):
        """
        Retrieve live photo
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_live_photo(live_photo_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str live_photo_id: The live photo’s unique identifier. (required)
        :return: LivePhoto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_live_photo_with_http_info(live_photo_id, **kwargs)
        else:
            (data) = self.find_live_photo_with_http_info(live_photo_id, **kwargs)
            return data

    def find_live_photo_with_http_info(self, live_photo_id, **kwargs):
        """
        Retrieve live photo
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_live_photo_with_http_info(live_photo_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str live_photo_id: The live photo’s unique identifier. (required)
        :return: LivePhoto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['live_photo_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_live_photo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'live_photo_id' is set
        if ('live_photo_id' not in params) or (params['live_photo_id'] is None):
            raise ValueError("Missing the required parameter `live_photo_id` when calling `find_live_photo`")


        collection_formats = {}

        resource_path = '/live_photos/{live_photo_id}'.replace('{format}', 'json')
        path_params = {}
        if 'live_photo_id' in params:
            path_params['live_photo_id'] = params['live_photo_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LivePhoto',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_report(self, check_id, report_id, **kwargs):
        """
        A single report can be retrieved using this endpoint with the corresponding unique identifier.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_report(check_id, report_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :param str report_id:  (required)
        :return: Report
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_report_with_http_info(check_id, report_id, **kwargs)
        else:
            (data) = self.find_report_with_http_info(check_id, report_id, **kwargs)
            return data

    def find_report_with_http_info(self, check_id, report_id, **kwargs):
        """
        A single report can be retrieved using this endpoint with the corresponding unique identifier.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_report_with_http_info(check_id, report_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :param str report_id:  (required)
        :return: Report
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['check_id', 'report_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params) or (params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `find_report`")
        # verify the required parameter 'report_id' is set
        if ('report_id' not in params) or (params['report_id'] is None):
            raise ValueError("Missing the required parameter `report_id` when calling `find_report`")


        collection_formats = {}

        resource_path = '/checks/{check_id}/reports/{report_id}'.replace('{format}', 'json')
        path_params = {}
        if 'check_id' in params:
            path_params['check_id'] = params['check_id']
        if 'report_id' in params:
            path_params['report_id'] = params['report_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Report',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_report_type_group(self, report_type_group_id, **kwargs):
        """
        Retrieve single report type group object
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_report_type_group(report_type_group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str report_type_group_id:  (required)
        :return: ReportTypeGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_report_type_group_with_http_info(report_type_group_id, **kwargs)
        else:
            (data) = self.find_report_type_group_with_http_info(report_type_group_id, **kwargs)
            return data

    def find_report_type_group_with_http_info(self, report_type_group_id, **kwargs):
        """
        Retrieve single report type group object
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_report_type_group_with_http_info(report_type_group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str report_type_group_id:  (required)
        :return: ReportTypeGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_type_group_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_report_type_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'report_type_group_id' is set
        if ('report_type_group_id' not in params) or (params['report_type_group_id'] is None):
            raise ValueError("Missing the required parameter `report_type_group_id` when calling `find_report_type_group`")


        collection_formats = {}

        resource_path = '/report_type_groups/{report_type_group_id}'.replace('{format}', 'json')
        path_params = {}
        if 'report_type_group_id' in params:
            path_params['report_type_group_id'] = params['report_type_group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ReportTypeGroup',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def find_webhook(self, webhook_id, **kwargs):
        """
        Retrieve a Webhook
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_webhook(webhook_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str webhook_id:  (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.find_webhook_with_http_info(webhook_id, **kwargs)
        else:
            (data) = self.find_webhook_with_http_info(webhook_id, **kwargs)
            return data

    def find_webhook_with_http_info(self, webhook_id, **kwargs):
        """
        Retrieve a Webhook
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.find_webhook_with_http_info(webhook_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str webhook_id:  (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['webhook_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_webhook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'webhook_id' is set
        if ('webhook_id' not in params) or (params['webhook_id'] is None):
            raise ValueError("Missing the required parameter `webhook_id` when calling `find_webhook`")


        collection_formats = {}

        resource_path = '/webhooks/{webhook_id}'.replace('{format}', 'json')
        path_params = {}
        if 'webhook_id' in params:
            path_params['webhook_id'] = params['webhook_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Webhook',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def list_applicants(self, **kwargs):
        """
        List Applicants
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_applicants(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int page: The page to return. Defaults to the first page if omitted. The first page is `page=1`
        :param int per_page: The number of objects per page. Defaults to 20 if omitted.
        :param bool include_deleted: Whether to also include applicants scheduled for deletion. Defaults to false if omitted.
        :return: ApplicantsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_applicants_with_http_info(**kwargs)
        else:
            (data) = self.list_applicants_with_http_info(**kwargs)
            return data

    def list_applicants_with_http_info(self, **kwargs):
        """
        List Applicants
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_applicants_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int page: The page to return. Defaults to the first page if omitted. The first page is `page=1`
        :param int per_page: The number of objects per page. Defaults to 20 if omitted.
        :param bool include_deleted: Whether to also include applicants scheduled for deletion. Defaults to false if omitted.
        :return: ApplicantsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'per_page', 'include_deleted']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_applicants" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/applicants'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'page' in params:
            query_params['page'] = params['page']
        if 'per_page' in params:
            query_params['per_page'] = params['per_page']
        if 'include_deleted' in params:
            query_params['include_deleted'] = params['include_deleted']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ApplicantsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def list_checks(self, applicant_id, **kwargs):
        """
        Retrieve Checks
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_checks(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param int page: The page to return. Defaults to the first page if omitted. The first page is `page=1`
        :param int per_page: The number of objects per page. Defaults to 20 if omitted.
        :return: ChecksList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_checks_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.list_checks_with_http_info(applicant_id, **kwargs)
            return data

    def list_checks_with_http_info(self, applicant_id, **kwargs):
        """
        Retrieve Checks
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_checks_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param int page: The page to return. Defaults to the first page if omitted. The first page is `page=1`
        :param int per_page: The number of objects per page. Defaults to 20 if omitted.
        :return: ChecksList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'page', 'per_page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_checks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `list_checks`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/checks'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}
        if 'page' in params:
            query_params['page'] = params['page']
        if 'per_page' in params:
            query_params['per_page'] = params['per_page']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ChecksList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def list_documents(self, applicant_id, **kwargs):
        """
        List documents
        All documents belonging to an applicant can be listed from this endpoint

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_documents(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: DocumentsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_documents_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.list_documents_with_http_info(applicant_id, **kwargs)
            return data

    def list_documents_with_http_info(self, applicant_id, **kwargs):
        """
        List documents
        All documents belonging to an applicant can be listed from this endpoint

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_documents_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: DocumentsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `list_documents`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/documents'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DocumentsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def list_live_photos(self, applicant_id, **kwargs):
        """
        List live photos
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_live_photos(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id: The id of the applicant the live photos belongs to. (required)
        :return: LivePhotosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_live_photos_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.list_live_photos_with_http_info(applicant_id, **kwargs)
            return data

    def list_live_photos_with_http_info(self, applicant_id, **kwargs):
        """
        List live photos
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_live_photos_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id: The id of the applicant the live photos belongs to. (required)
        :return: LivePhotosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_live_photos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `list_live_photos`")


        collection_formats = {}

        resource_path = '/live_photos'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'applicant_id' in params:
            query_params['applicant_id'] = params['applicant_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LivePhotosList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def list_live_videos(self, applicant_id, **kwargs):
        """
        List live photos


        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_live_photos(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id: The id of the applicant the live photos belongs to. (required)
        :return: LiveVideosList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_live_videos_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.list_live_videos_with_http_info(applicant_id, **kwargs)
            return data

    def list_live_videos_with_http_info(self, applicant_id, **kwargs):
        """
        List live photos


        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_live_photos_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id: The id of the applicant the live photos belongs to. (required)
        :return: LiveVideosList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_live_photos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `list_live_photos`")

        collection_formats = {}

        resource_path = '/live_videos'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'applicant_id' in params:
            query_params['applicant_id'] = params['applicant_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client. \
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client. \
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LiveVideosList',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        collection_formats=collection_formats)

    def list_report_type_groups(self, **kwargs):
        """
        Retrieve all report type groups
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_report_type_groups(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ReportTypeGroupsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_report_type_groups_with_http_info(**kwargs)
        else:
            (data) = self.list_report_type_groups_with_http_info(**kwargs)
            return data

    def list_report_type_groups_with_http_info(self, **kwargs):
        """
        Retrieve all report type groups
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_report_type_groups_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ReportTypeGroupsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_report_type_groups" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/report_type_groups'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ReportTypeGroupsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def list_reports(self, check_id, **kwargs):
        """
        All the reports belonging to a particular check can be listed from this endpoint.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_reports(check_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :return: ReportsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_reports_with_http_info(check_id, **kwargs)
        else:
            (data) = self.list_reports_with_http_info(check_id, **kwargs)
            return data

    def list_reports_with_http_info(self, check_id, **kwargs):
        """
        All the reports belonging to a particular check can be listed from this endpoint.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_reports_with_http_info(check_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :return: ReportsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['check_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_reports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params) or (params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `list_reports`")


        collection_formats = {}

        resource_path = '/checks/{check_id}/reports'.replace('{format}', 'json')
        path_params = {}
        if 'check_id' in params:
            path_params['check_id'] = params['check_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ReportsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def list_webhooks(self, **kwargs):
        """
        List webhooks
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_webhooks(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: WebhooksList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_webhooks_with_http_info(**kwargs)
        else:
            (data) = self.list_webhooks_with_http_info(**kwargs)
            return data

    def list_webhooks_with_http_info(self, **kwargs):
        """
        List webhooks
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_webhooks_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: WebhooksList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_webhooks" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        resource_path = '/webhooks'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='WebhooksList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def restore_applicant(self, applicant_id, **kwargs):
        """
        Restore Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.restore_applicant(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.restore_applicant_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.restore_applicant_with_http_info(applicant_id, **kwargs)
            return data

    def restore_applicant_with_http_info(self, applicant_id, **kwargs):
        """
        Restore Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.restore_applicant_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_applicant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `restore_applicant`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/restore'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def resume_check(self, check_id, **kwargs):
        """
        Resume a Check
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resume_check(check_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.resume_check_with_http_info(check_id, **kwargs)
        else:
            (data) = self.resume_check_with_http_info(check_id, **kwargs)
            return data

    def resume_check_with_http_info(self, check_id, **kwargs):
        """
        Resume a Check
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resume_check_with_http_info(check_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['check_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_check" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params) or (params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `resume_check`")


        collection_formats = {}

        resource_path = '/checks/{check_id}/resume'.replace('{format}', 'json')
        path_params = {}
        if 'check_id' in params:
            path_params['check_id'] = params['check_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def resume_report(self, check_id, report_id, **kwargs):
        """
        This endpoint is for resuming individual paused reports.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resume_report(check_id, report_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :param str report_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.resume_report_with_http_info(check_id, report_id, **kwargs)
        else:
            (data) = self.resume_report_with_http_info(check_id, report_id, **kwargs)
            return data

    def resume_report_with_http_info(self, check_id, report_id, **kwargs):
        """
        This endpoint is for resuming individual paused reports.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resume_report_with_http_info(check_id, report_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str check_id:  (required)
        :param str report_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['check_id', 'report_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params) or (params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `resume_report`")
        # verify the required parameter 'report_id' is set
        if ('report_id' not in params) or (params['report_id'] is None):
            raise ValueError("Missing the required parameter `report_id` when calling `resume_report`")


        collection_formats = {}

        resource_path = '/checks/{check_id}/reports/{report_id}/resume'.replace('{format}', 'json')
        path_params = {}
        if 'check_id' in params:
            path_params['check_id'] = params['check_id']
        if 'report_id' in params:
            path_params['report_id'] = params['report_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def update_applicant(self, applicant_id, **kwargs):
        """
        Update Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_applicant(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param Applicant data: 
        :return: Applicant
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_applicant_with_http_info(applicant_id, **kwargs)
        else:
            (data) = self.update_applicant_with_http_info(applicant_id, **kwargs)
            return data

    def update_applicant_with_http_info(self, applicant_id, **kwargs):
        """
        Update Applicant
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_applicant_with_http_info(applicant_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param Applicant data: 
        :return: Applicant
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'data']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_applicant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `update_applicant`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Applicant',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def upload_document(self, applicant_id, type, **kwargs):
        """
        Upload a document
        Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_document(applicant_id, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str type:  (required)
        :param str side: 
        :param file file:
        :param file_object file_object: tuple of (filename, filedata, mimetype)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_document_with_http_info(applicant_id, type, **kwargs)
        else:
            (data) = self.upload_document_with_http_info(applicant_id, type, **kwargs)
            return data

    def upload_document_with_http_info(self, applicant_id, type, **kwargs):
        """
        Upload a document
        Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_document_with_http_info(applicant_id, type, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id:  (required)
        :param str type:  (required)
        :param str side: 
        :param file file:
        :param file_object file_object: tuple of (filename, filedata, mimetype)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'type', 'side', 'file', 'file_object', 'issuing_country']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `upload_document`")
        # verify the required parameter 'type' is set
        if ('type' not in params) or (params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `upload_document`")


        collection_formats = {}

        resource_path = '/applicants/{applicant_id}/documents'.replace('{format}', 'json')
        path_params = {}
        if 'applicant_id' in params:
            path_params['applicant_id'] = params['applicant_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'type' in params:
            form_params.append(('type', params['type']))
        if 'side' in params:
            form_params.append(('side', params['side']))
        if 'issuing_country' in params:
            form_params.append(('issuing_country', params['issuing_country']))
        if 'file' in params:
            local_var_files['file'] = params['file']
        if 'file_object' in params:
            local_var_files['file_object'] = params['file_object']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Document',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)

    def upload_live_photo(self, applicant_id, file, **kwargs):
        """
        Upload live photo
        You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_live_photo(applicant_id, file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id: The applicant_id to associate the live photo to. (required)
        :param file file: The file to be uploaded. (required if no file_object)
        :param file_object file_object: tuple of (filename, filedata, mimetype)
        :param bool advanced_validation: Validates that the live photo contains exactly one face.
        :return: LivePhoto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_live_photo_with_http_info(applicant_id, file, **kwargs)
        else:
            (data) = self.upload_live_photo_with_http_info(applicant_id, file, **kwargs)
            return data

    def upload_live_photo_with_http_info(self, applicant_id, file, **kwargs):
        """
        Upload live photo
        You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_live_photo_with_http_info(applicant_id, file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str applicant_id: The applicant_id to associate the live photo to. (required)
        :param file file: The file to be uploaded. (required if no file_object)
        :param file_object file_object: tuple of (filename, filedata, mimetype)
        :param bool advanced_validation: Validates that the live photo contains exactly one face.
        :return: LivePhoto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicant_id', 'file', 'file_object', 'advanced_validation']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_live_photo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'applicant_id' is set
        if ('applicant_id' not in params) or (params['applicant_id'] is None):
            raise ValueError("Missing the required parameter `applicant_id` when calling `upload_live_photo`")
        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            if ('file_object' not in params) or (params['file_object'] is None):
                raise ValueError("Missing the required parameter `file` or `file_object` when calling `upload_live_photo`")


        collection_formats = {}

        resource_path = '/live_photos'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'applicant_id' in params:
            form_params.append(('applicant_id', params['applicant_id']))
        if 'file' in params:
            local_var_files['file'] = params['file']
        if 'file_object' in params:
            local_var_files['file_object'] = params['file_object']
        if 'advanced_validation' in params:
            form_params.append(('advanced_validation', params['advanced_validation']))

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['Token']

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LivePhoto',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'),
                                            _preload_content=params.get('_preload_content', True),
                                            collection_formats=collection_formats)
